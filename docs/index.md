## Общее описание
AsSharp – функциональный компилируемый язык программирования, который осуществляет парсинг кода и его трансляцию в JavaScript.
Язык соответствует функциональной парадигме, поскольку в его реализации:
- Всякая функция однозначно определяет результат по любому набору аргументов.
- Отсутствует оператор присваивания.
- Переменная обозначает только имя структуры.
- В языке присутствуют функционалы — функции, аргументы и результаты которых могут быть функциями.

Язык универсальный, предназначен для решения широкого диапазона задач,
позволяя производить вычисления с разными типами данных.
В то же время в AsSharp реализованы такие структуры управления как условные операторы и циклы,
которые позволяют изменять порядок выполнения инструкций в зависимости от данных.
Он позволяет хранить и изменять данные во время выполнения программы через переменные и списки,
поддерживает определение и вызов функций или подпрограмм, что позволяет выполнять повторяющиеся или модульные задачи.
В целом, теоретически язык может исполнять программы с неограниченными ресурсами памяти и времени,
а также на нём можно реализовать любой вычислимый алгоритм, что делает его полным по Тьюрингу.

## Синтаксис языка
В синтаксисе языка используются ключевые слова на русском языке, которые обеспечивают простое и интуитивное понимание контекста.

В AsSharp реализованы следующие типы данных:

|Тип данных|Обозначение|
|-|-|
|Логический|МАРКЕР_ДНА|
|Строковый|ЦЕПОЧКА|
|Символьный|ПРЁФИКС|
|Целочисленный|ЭПСИЛЁН|
|С плавающей точкой|ГАММА_ШТРИХ|
|Void|ЛЯМБДА|
|None|НУЛЬ_ТЕРМИНАЛ|

Ключевые слова, которые имеют особое значение для компилятора, обозначаются следующим образом:

|Ключевые слова|Обозначение|
|-|-|
|Инициализация функции|ПРАВИЛО|
|Инициализация отложенных вычислений|СТУДЕНТ|
|Анонимная функция|ФОРЫЧ|
|Инициализация переменной|ФАКТ|
|Списки|ЛЕНТА|
|Комментарии|КРОЛ|
|if|ПЕРЕХОД|
|then|ДА|
|else|НЕТ|
|true|ПРАВДА|
|false|ЛОЖЬ|
|is|ЕСТЬ|
|set|УСТАНОВИТЬ|

Также реализованы унарные операторы, которые могут изменять значение операнда, и бинарные, которые работают с двумя операндами и выполняют операцию между ними:

|Оператор|Обозначение|
|-|-|
|Сложение|ПРОДУКЦИЯ|
|Вычитание|РЕДУКЦИЯ|
|Замыкание|ЗАМЫКАНИЕ|
|Остаток от деления|РАЗМЫКАНИЕ|
|Целочисленное деление|КУСОК|
|Равенство|СИНТАКСИЧЕСКИ_РАВЕН|
|Неравенство|СИНТАКСИЧЕСКИ_НЕРАВЕН|
|Больше|ПРЕВЫШЕНИЕ_ПРЕОРИТЕТА|
|Меньше|УСТУПАЕТ_ПРЕОРИТЕТОМ|
|Конъюнкия|КОНЮНКЦИЯ|
|Дизъюнкция|ДИЗЮНКЦИЯ|
|Унарный минус|МИНУСЬ|
|Унарный плюс|ПЛЮСЬ|
|Инверсия|ИНВЁРС|

Встроенные функции обозначаются следующим образом:

|||
|-|-|
|Преобразование в логический тип|В_МАРКЕР_ДНА|
|Преобразование в символьный тип|В_ПРЁФИКС|
|Преобразование в строковый тип|В_ЦЕПОЧКУ|
|Преобразование в целочисленный тип|В_ЭПСИЛЁН|
|Преобразование в тип c плавающей точкой|В_ГАММА_ШТРИХ|
|read|ИЗ_МП|
|write|В_МП|
|len|МОЩНОСТЬ|
|insert|ИНСЁРТ|
|remove|ВЫЧЕТ|
|return|ВОЗДАТЬ|
|force|ПИНАТЬ|

## AST-дерево

AST-дерево, или абстрактное синтаксическое дерево (Abstract Syntax Tree), — это структура данных, используемая в компиляторах для представления синтаксической структуры исходного кода программы в иерархической форме. AST-дерево играет важную роль в процессе анализа и преобразования кода, так как позволяет компилятору или интерпретатору работать с программой на более высоком уровне абстракции. Процесс создания AST начинается с лексического анализа исходного кода, в результате которого текст программы преобразуется в последовательность токенов. Токены — это значимые элементы программы, такие как идентификаторы, ключевые слова, литералы, операторы и знаки пунктуации. Далее, на этапе синтаксического анализа, последовательность токенов обрабатывается согласно грамматике языка программирования для построения AST. В этом дереве каждый узел представляет собой конструкцию языка.

Реализация языка описывает структуры для построения абстрактного синтаксического дерева (AST) для компилятора на языке F#. Он включает определения для различных типов выражений, данных и операторов, которые могут быть использованы для анализа и трансформации исходного кода в рамках компиляции или интерпретации. Вот ключевые элементы этого кода:

- Типы выражений (Expr): Описывает разнообразные формы выражений, такие как литералы, унарные и бинарные операции, вызовы функций и другие. Это позволяет представлять и обрабатывать все возможные выражения в языке.
- Типы операторов (Stmt): Определяет различные операторы языка, такие как определение функций, определение переменных, выражения и условные конструкции.
- Блоки (Block): Список операторов, объединенных в блоки, используемые в функциях и условных конструкциях.
- Встроенные функции (BuiltInFunc): Набор функций, предоставляемых языком для выполнения стандартных операций, таких как ввод-вывод, работа со списками и преобразование типов.
- Типы данных (DataType): Перечисление типов данных, поддерживаемых в языке, включая примитивные типы и составные структуры, такие как списки.
- Ключевые слова и типы скобок (Keyword, BracketType): Помогают в синтаксическом анализе и структурировании кода, определяя специальные слова и типы скобок, используемые в языке.
  
Это используется для подготовки структурированного представления программы, облегчая её дальнейшую обработку на этапах компиляции или интерпретации.

## Лексер и парсер

Лексер, также известный как лексический анализатор или сканер, обрабатывает исходный код на самом начальном этапе компиляции. Он считывает последовательность символов (текст программы) и преобразует их в последовательность токенов. Токены — это смысловые единицы, такие как ключевые слова, идентификаторы, литералы, операторы и другие значимые символьные последовательности.

1. Пропуск пробелов и комментариев:
- ws0: Парсер, пропускающий одиночные пробелы, табуляцию или переводы строк.
- ws1: Парсер, пропускающий один или более пробелов.
- wsComment: Парсер, распознающий комментарии, начинающиеся с определённой строки (возвращаемой getCommentName), и пропускающий весь остаток строки.
- ws: Общий парсер, пропускающий любые пробелы или комментарии.
2. Распознавание ключевых слов, типов данных и встроенных функций:
- keyword, datatype, builtin: Парсеры, которые распознают ключевые слова, типы данных и имена встроенных функций, соответственно, пропуская пробелы после них.
3. Обработка скобок и списков:
- bracket: Парсер, который обрабатывает выражения, заключённые в скобки, используя функцию translate для преобразования результатов парсинга.
- separate: Парсер, который разделяет элементы списков с помощью разделителя (запятая или другой символ, определённый как Separator).
4. Распознавание литералов:
- integer, float: Парсеры для распознавания целых и вещественных чисел.
- string, char: Парсеры для распознавания строк и символов, заключённых в кавычки.
- boolean: Парсер для булевых значений, распознающий ключевые слова True и False.
5. Распознавание идентификаторов:
- identifierS: Парсер для распознавания идентификаторов, состоящих из букв и цифр.

Парсер принимает на вход последовательность токенов от лексера и строит из них абстрактное синтаксическое дерево (AST) или другую форму синтаксического представления программы. Абстрактное синтаксическое дерево отражает синтаксическую структуру программы, где каждый узел дерева представляет собой конструкцию языка.

Основные функции парсера:

- Анализ: Проверка последовательности токенов на соответствие синтаксическим правилам языка программирования. Это включает определение, как токены группируются в инструкции или выражения.
- Построение дерева: Создание структурированного представления кода (например, AST), которое используется для дальнейшей обработки, такой как семантический анализ, оптимизация и генерация кода.
- Обработка ошибок: Обнаружение и сообщение о синтаксических ошибках, обнаруженных во время анализа.

Используя библиотеку FParsec, код определяет различные функции для анализа и преобразования исходного текста программы в структуры данных, представляющие выражения, операторы и блоки кода.
Функция pipe2 используется для создания нового парсера путём последовательного применения двух парсеров к входным данным и последующего комбинирования их результатов с помощью функции, передаваемой в качестве аргумента. Пример использования pipe2 в коде:
- parseBuiltInFuncCall: Создаёт парсер для вызова встроенной функции, сначала определяя функцию из списка возможных функций, а затем парся аргументы функции. Результаты комбинируются в структуру Expr.BuiltInFuncCall.
- parseCall: Анализирует вызовы функций или методов, сначала распознавая выражение, а затем аргументы вызова, и объединяя их в структуру вызова функции.

Функция pipe3 аналогична pipe2, но применяется к трем парсерам. Она последовательно применяет три парсера и комбинирует их результаты с помощью функции, передаваемой в качестве аргумента. Примеры использования pipe3 в коде:
- parseFunc: Анализирует анонимные функции, сначала парся тип данных функции, затем список аргументов, и в конце тело функции, объединяя всё в структуру Expr.Func.
- parseIfStmt: Парсит условные выражения if, сначала условие, затем блок кода для then и необязательный блок для else, объединяя результаты в структуру Stmt.IfStmt.

Лексер и парсер вместе образуют фронтенд компилятора, который преобразует исходный текст в структурированную форму, подготовленную для дальнейшего анализа и преобразования в исполняемый код.

## Транслятор

Транслятор — это тип программного обеспечения, который преобразует исходный код, написанный на одном языке программирования, в эквивалентный код на другом языке программирования или в машинный код, который может непосредственно выполняться процессором. Основная цель транслятора — перевести программы так, чтобы они стали понятны для другой системы или для выполнения на другом уровне абстракции.

В реализации языка описана генерация JavaScript из некоторого абстрактного синтаксического дерева (AST). Он состоит из нескольких основных частей:

1. **Реализация потоков ввода/вывода**:
   - Ввод (`argv`) обрабатывается с помощью функции `BuiltInFunc.Read`, которая смещает (`shift()`) массив `argv`, предположительно содержащий аргументы командной строки.
   - Вывод (`output`) реализуется через `BuiltInFunc.Write`, который добавляет (`push()`) результаты выражений в массив `output`. Этот массив возвращается в конце выполнения программы.

2. **Ленивые вычисления в JavaScript**:
   - Функция `Force` реализует ленивые вычисления. Она создаёт кэширование результатов вычисления функции. Если результат уже кэширован, он возвращается без повторного выполнения функции. Это позволяет отложить выполнение до первого требования результата и избежать повторного выполнения.

3. **Функциональное программирование в JavaScript**:
   - Функции и рекурсия реализуются через конструкции `Func` и `FuncDef`, которые создают анонимные функции или именованные функции соответственно.
   - Замыкания реализованы через возможность функций захватывать контекст, в котором они были созданы, что позволяет использовать переменные из внешнего контекста.
   - Функции высшего порядка реализованы через передачу функций как аргументов или их возвращение из других функций.

Каждый узел AST обрабатывается в функции `exprToJs`, которая рекурсивно генерирует JavaScript код для различных типов выражений, таких как литералы, идентификаторы, вызовы функций, условные операторы и т.д. Код завершается шаблонами `jsPrev` и `jsAfter`, которые формируют структуру программы, обрабатывающей аргументы и возвращающей результаты.


## Онлайн IDE

1. Использована библиотека React-simple-code-editor
2. Клиентская часть состоит из компонентов:
   - редактора кода
   - подстветки синтаксиса
   - поля отладки
3. Подстветка кода реализована с использованием регулярных выражений
4. Сервер написан ASP.NET Core web API, принимает запросы из клиентской части на языке и выдает скомпилированный код на JavaScript
5. Клиентская и серверная части развёрнуты в разных контейнерах Docker и связаны с помощью Docker Compose. 

## Примеры программ на языке

Проверка на простоту:
![image](https://github.com/valerasaray/fp_documentation/assets/55214180/64657b4e-3810-403d-90f7-96ee6e05c517)

Число сочетаний:
![image](https://github.com/valerasaray/fp_documentation/assets/55214180/3ee7c443-6471-49d1-a832-602c80202a69)

Поиск наибольшего общего делителя:
![image](https://github.com/valerasaray/fp_documentation/assets/55214180/2055c9ec-6066-4924-94f2-bb244695239d)

Замыкание:
![image](https://github.com/valerasaray/fp_documentation/assets/55214180/dba5ac7b-ea30-434c-9016-d1448a88aa6f)

Рекурсия:
![image](https://github.com/valerasaray/fp_documentation/assets/55214180/96b25892-775a-4b47-a8d0-4472984c5564)



## Инструкция по запуску

Для запуска в корне репозитория прописать команду:
```
docker-compose -f ./docker-compose.yml up --build
```
